"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6751],{46751:(e,t,r)=>{r.r(t),r.d(t,{AdminService:()=>n,AnalyticsService:()=>g,AppSettingsService:()=>u,CooksService:()=>a,DishesService:()=>c,DriversService:()=>l,OrdersService:()=>s,ReviewsService:()=>d});var o=r(35317),i=r(66579);class c{static async getAllDishes(){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.orderBy)("createdAt","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching dishes with orderBy, trying fallback:",e),this.getAllDishesFallback()}}static async getAllDishesFallback(){try{return(await (0,o.getDocs)((0,o.collection)(i.db,this.collection))).docs.map(e=>({id:e.id,...e.data()})).sort((e,t)=>{var r,o;let i=(null==(r=e.createdAt)?void 0:r.toMillis())||0;return((null==(o=t.createdAt)?void 0:o.toMillis())||0)-i})}catch(e){return console.error("Error fetching dishes (fallback):",e),[]}}static async getDishesByCategory(e){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("category","==",e),(0,o.where)("isAvailable","==",!0),(0,o.orderBy)("rating","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(t){return console.error("Error fetching dishes by category with index, trying fallback:",t),this.getDishesByCategoryFallback(e)}}static async getDishesByCategoryFallback(e){try{return(await (0,o.getDocs)((0,o.collection)(i.db,this.collection))).docs.map(e=>({id:e.id,...e.data()})).filter(t=>t.category===e&&t.isAvailable).sort((e,t)=>(t.rating||0)-(e.rating||0))}catch(e){return console.error("Error fetching dishes by category (fallback):",e),[]}}static async getDishesByCook(e){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("cookerId","==",e),(0,o.orderBy)("createdAt","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(t){return console.warn("Database index is building, using temporary fallback method..."),this.getDishesByCookFallback(e)}}static async getDishesByCookFallback(e){try{try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("cookerId","==",e)))).docs.map(e=>({id:e.id,...e.data()})).sort((e,t)=>{var r,o;let i=(null==(r=e.createdAt)?void 0:r.toMillis())||0;return((null==(o=t.createdAt)?void 0:o.toMillis())||0)-i})}catch(t){return console.warn("Simple query failed, using full collection scan..."),(await (0,o.getDocs)((0,o.collection)(i.db,this.collection))).docs.map(e=>({id:e.id,...e.data()})).filter(t=>t.cookerId===e).sort((e,t)=>{var r,o;let i=(null==(r=e.createdAt)?void 0:r.toMillis())||0;return((null==(o=t.createdAt)?void 0:o.toMillis())||0)-i})}}catch(e){return console.error("Error fetching dishes by cook (fallback):",e),[]}}static async getDishById(e){try{let t=(0,o.doc)(i.db,this.collection,e),r=await (0,o.getDoc)(t);if(r.exists())return{id:r.id,...r.data()};return null}catch(e){return console.error("Error fetching dish:",e),null}}static async createDish(e){try{let t=o.Dc.now();return(await (0,o.gS)((0,o.collection)(i.db,this.collection),{...e,createdAt:t,updatedAt:t})).id}catch(e){return console.error("Error creating dish:",e),null}}static async updateDish(e,t){try{let r=(0,o.doc)(i.db,this.collection,e);return await (0,o.mZ)(r,{...t,updatedAt:o.Dc.now()}),!0}catch(e){return console.error("Error updating dish:",e),!1}}static async deleteDish(e){try{return await (0,o.kd)((0,o.doc)(i.db,this.collection,e)),!0}catch(e){return console.error("Error deleting dish:",e),!1}}static async searchDishes(e){try{return(await (0,o.getDocs)((0,o.collection)(i.db,this.collection))).docs.map(e=>({id:e.id,...e.data()})).filter(t=>t.name.toLowerCase().includes(e.toLowerCase())||t.description.toLowerCase().includes(e.toLowerCase())||t.tags.some(t=>t.toLowerCase().includes(e.toLowerCase()))||t.cookerName.toLowerCase().includes(e.toLowerCase()))}catch(e){return console.error("Error searching dishes:",e),[]}}static async getUserFavorites(e){try{let t=await (0,o.getDoc)((0,o.doc)(i.db,"favorites",e));if(t.exists())return t.data().dishIds||[];return[]}catch(e){return console.error("Error fetching user favorites:",e),[]}}static async addToFavorites(e,t){try{let r=(0,o.doc)(i.db,"favorites",e),c=await (0,o.getDoc)(r);if(c.exists()){let e=c.data().dishIds||[];e.includes(t)||await (0,o.mZ)(r,{dishIds:[...e,t],updatedAt:o.Dc.now()})}else await (0,o.BN)(r,{dishIds:[t],createdAt:o.Dc.now(),updatedAt:o.Dc.now()});return!0}catch(e){return console.error("Error adding to favorites:",e),!1}}static async removeFromFavorites(e,t){try{let r=(0,o.doc)(i.db,"favorites",e),c=await (0,o.getDoc)(r);if(c.exists()){let e=(c.data().dishIds||[]).filter(e=>e!==t);await (0,o.mZ)(r,{dishIds:e,updatedAt:o.Dc.now()})}return!0}catch(e){return console.error("Error removing from favorites:",e),!1}}}c.collection="dishes";class a{static async getAllCooks(){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.orderBy)("rating","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching cooks:",e),[]}}static async getCookById(e){try{let t=(0,o.doc)(i.db,this.collection,e),r=await (0,o.getDoc)(t);if(r.exists())return{id:r.id,...r.data()};return null}catch(e){return console.error("Error fetching cook:",e),null}}static async updateCookProfile(e,t){try{let r=(0,o.doc)(i.db,this.collection,e);return await (0,o.mZ)(r,{...t,updatedAt:o.Dc.now()}),!0}catch(e){return console.error("Error updating cook profile:",e),!1}}static async createCookProfile(e){try{let t=o.Dc.now();return(await (0,o.gS)((0,o.collection)(i.db,this.collection),{...e,createdAt:t,updatedAt:t})).id}catch(e){return console.error("Error creating cook profile:",e),null}}static async createCookProfileWithId(e,t){try{let r=o.Dc.now(),c=(0,o.doc)(i.db,this.collection,e);return await (0,o.BN)(c,{...t,createdAt:r,updatedAt:r}),!0}catch(e){return console.error("Error creating cook profile with ID:",e),!1}}}a.collection="cooks";class s{static async getAllOrders(){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.orderBy)("createdAt","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching all orders:",e),[]}}static async getOrdersByCustomer(e){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("customerId","==",e),(0,o.orderBy)("createdAt","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching customer orders:",e),[]}}static async getOrdersByCook(e){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("cookerId","==",e),(0,o.orderBy)("createdAt","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching cook orders:",e),[]}}static async getOrderById(e){try{let t=(0,o.doc)(i.db,this.collection,e),r=await (0,o.getDoc)(t);if(r.exists())return{id:r.id,...r.data()};return null}catch(e){return console.error("Error fetching order by ID:",e),null}}static async createOrder(e){try{let t=o.Dc.now(),{generateDeliveryCode:c}=await Promise.resolve().then(r.bind(r,53999)),s=await (0,o.gS)((0,o.collection)(i.db,this.collection),{...e,deliveryCode:e.deliveryCode||c(),isDelivered:!1,createdAt:t,updatedAt:t});try{let o=await a.getCookById(e.cookerId);if(o&&o.email){let{EmailService:i}=await r.e(9920).then(r.bind(r,79920)),c={id:s.id,...e,createdAt:t,updatedAt:t};await i.sendOrderNotificationToCook(c,o),console.log("Email notification sent to cook ".concat(o.email," for order ").concat(s.id))}}catch(e){console.error("Error sending email notification to cook:",e)}try{let{ChatService:t}=await r.e(7764).then(r.bind(r,17764));await t.getOrCreateOrderChatRoom(s.id,e.cookerId,e.customerId,e.driverId)}catch(e){console.warn("Could not create chat room for order:",e)}return s.id}catch(e){return console.error("Error creating order:",e),null}}static async updateOrderStatus(e,t,c){try{let a=(0,o.doc)(i.db,this.collection,e),s={status:t,updatedAt:o.Dc.now()};if("delivered"===t?(s.actualDeliveryTime=o.Dc.now(),s.isDelivered=!0):"ready"===t?(s.availableForPickup=!0,s.readyTime=o.Dc.now()):"delivering"===t&&(null==c?void 0:c.userId)&&(s.driverId=c.userId,s.pickupTime=o.Dc.now()),await (0,o.mZ)(a,s),c&&["accepted","preparing","ready","delivering","delivered"].includes(t))try{let{ChatService:i}=await r.e(7764).then(r.bind(r,17764)),s=await (0,o.getDoc)(a);if(s.exists()){let r=s.data(),o=await i.getOrCreateOrderChatRoom(e,r.cookerId,r.customerId,r.driverId);o&&await i.sendOrderUpdateMessage(o,e,t,c.role)}}catch(e){console.warn("Could not send chat notification for status update:",e)}return!0}catch(e){return console.error("Error updating order status:",e),!1}}static async updateOrder(e,t){try{let r=(0,o.doc)(i.db,this.collection,e);return await (0,o.mZ)(r,{...t,updatedAt:o.Dc.now()}),!0}catch(e){return console.error("Error updating order:",e),!1}}static async verifyDeliveryCode(e,t){try{let r=(0,o.doc)(i.db,this.collection,e),c=await (0,o.getDoc)(r);if(!c.exists())return{success:!1,message:"Pedido no encontrado"};let a=c.data();if(a.isDelivered)return{success:!1,message:"Este pedido ya fue entregado"};if("delivering"!==a.status)return{success:!1,message:"Este pedido no est\xe1 en estado de entrega"};if(a.deliveryCode!==t)return{success:!1,message:"C\xf3digo de entrega incorrecto"};return await (0,o.mZ)(r,{status:"delivered",isDelivered:!0,actualDeliveryTime:o.Dc.now(),updatedAt:o.Dc.now()}),{success:!0,message:"Pedido entregado exitosamente"}}catch(e){return console.error("Error verifying delivery code:",e),{success:!1,message:"Error al verificar el c\xf3digo"}}}static async getOrderByDeliveryCode(e){try{let t=await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("deliveryCode","==",e),(0,o.where)("status","==","delivering"),(0,o.where)("isDelivered","==",!1)));if(t.empty)return null;let r=t.docs[0];return{id:r.id,...r.data()}}catch(e){return console.error("Error finding order by delivery code:",e),null}}static async getAvailableOrdersForDelivery(){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("status","in",["accepted","preparing","ready"]),(0,o.orderBy)("createdAt","asc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching available orders:",e),[]}}static async assignOrderToDriver(e,t){try{let r=(0,o.doc)(i.db,this.collection,e);return await (0,o.mZ)(r,{driverId:t,status:"delivering",pickupTime:o.Dc.now(),updatedAt:o.Dc.now()}),!0}catch(e){return console.error("Error assigning order to driver:",e),!1}}static async getReadyOrdersForPickup(){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("status","==","ready")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching ready orders:",e),[]}}static subscribeToAvailableOrders(e){let t=(0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("status","in",["pending","accepted","preparing","ready"]));return(0,o.aQ)(t,t=>{let r=t.docs.map(e=>({id:e.id,...e.data()}));r.sort((e,t)=>{var r,o;return((null==(r=e.createdAt)?void 0:r.toMillis())||0)-((null==(o=t.createdAt)?void 0:o.toMillis())||0)}),e(r)},t=>{console.error("Error in available orders subscription:",t),e([])})}static subscribeToOrderUpdates(e,t){let r=(0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("cookerId","==",e),(0,o.orderBy)("createdAt","desc"));return(0,o.aQ)(r,e=>{t(e.docs.map(e=>({id:e.id,...e.data()})))})}static subscribeToDriverAvailableOrders(e){let t=(0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("status","in",["pending","accepted","preparing","ready"]));return(0,o.aQ)(t,t=>{let r=t.docs.map(e=>({id:e.id,...e.data()}));r.sort((e,t)=>{var r,o;return((null==(r=e.createdAt)?void 0:r.toMillis())||0)-((null==(o=t.createdAt)?void 0:o.toMillis())||0)}),e(r)},t=>{console.error("Error in driver available orders subscription:",t),e([])})}static subscribeToCustomerOrders(e,t){let r=(0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("customerId","==",e));return(0,o.aQ)(r,e=>{let r=e.docs.map(e=>({id:e.id,...e.data()}));r.sort((e,t)=>{var r,o;let i=(null==(r=e.createdAt)?void 0:r.toDate())||new Date(0);return((null==(o=t.createdAt)?void 0:o.toDate())||new Date(0)).getTime()-i.getTime()}),t(r)},e=>{console.error("Error in customer orders subscription:",e),t([])})}static subscribeToOrdersByCook(e,t){let r=(0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("cookerId","==",e));return(0,o.aQ)(r,e=>{let r=e.docs.map(e=>({id:e.id,...e.data()}));r.sort((e,t)=>{var r,o;let i=(null==(r=e.createdAt)?void 0:r.toDate())||new Date(0);return((null==(o=t.createdAt)?void 0:o.toDate())||new Date(0)).getTime()-i.getTime()}),t(r)},e=>{console.error("Error in cook orders subscription:",e),t([])})}static subscribeToOrder(e,t){return(0,o.aQ)((0,o.doc)(i.db,this.collection,e),e=>{e.exists()?t({id:e.id,...e.data()}):t(null)},e=>{console.error("Error in order subscription:",e),t(null)})}static async addOrderReview(e,t){try{return await (0,o.mZ)((0,o.doc)(i.db,this.collection,e),{review:t,reviewed:!0,updatedAt:o.Dc.now()}),!0}catch(e){return console.error("Error adding order review:",e),!1}}static async deleteOrder(e){try{return await (0,o.kd)((0,o.doc)(i.db,this.collection,e)),!0}catch(e){return console.error("Error deleting order:",e),!1}}static async startDeliveryTracking(e,t){try{let r=o.Dc.now();return await (0,o.mZ)((0,o.doc)(i.db,this.collection,e),{status:"en_viaje",tracking:{driverLocation:{...t,timestamp:r},trackingStarted:r,lastLocationUpdate:r},updatedAt:r}),!0}catch(e){return console.error("Error starting delivery tracking:",e),!1}}static async updateDriverLocation(e,t,r){try{let c=o.Dc.now(),a={"tracking.driverLocation":{...t,timestamp:c},"tracking.lastLocationUpdate":c,updatedAt:c};return r&&(a["tracking.route"]={...r,estimatedArrival:o.Dc.fromDate(r.estimatedArrival)}),await (0,o.mZ)((0,o.doc)(i.db,this.collection,e),a),!0}catch(e){return console.error("Error updating driver location:",e),!1}}static async endDeliveryTracking(e){try{let t=o.Dc.now();return await (0,o.mZ)((0,o.doc)(i.db,this.collection,e),{status:"delivered","tracking.trackingEnded":t,actualDeliveryTime:t,updatedAt:t}),!0}catch(e){return console.error("Error ending delivery tracking:",e),!1}}static async getOrdersWithDetails(){try{let e=await this.getAllOrders(),t=[...new Set(e.map(e=>e.cookerId).filter(Boolean))],r=[...new Set(e.map(e=>e.driverId).filter(Boolean))],[o,i]=await Promise.all([Promise.all(t.map(async e=>{let t=await a.getCookById(e);return{id:e,data:t}})),Promise.all(r.map(async e=>{let t=await l.getDriverById(e);return{id:e,data:t}}))]),c=new Map(o.map(e=>[e.id,e.data])),s=new Map(i.map(e=>[e.id,e.data]));return e.map(e=>({...e,cookInfo:e.cookerId?c.get(e.cookerId):void 0,driverInfo:e.driverId?s.get(e.driverId):void 0}))}catch(e){return console.error("Error getting orders with details:",e),[]}}}s.collection="orders";class d{static async getReviewsByCook(e){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("cookerId","==",e),(0,o.orderBy)("createdAt","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(t){return console.error("Error fetching reviews with index, trying fallback:",t),this.getReviewsByCookFallback(e)}}static async getReviewsByCookFallback(e){try{return(await (0,o.getDocs)((0,o.collection)(i.db,this.collection))).docs.map(e=>({id:e.id,...e.data()})).filter(t=>t.cookerId===e).sort((e,t)=>{var r,o;let i=(null==(r=e.createdAt)?void 0:r.toMillis())||0;return((null==(o=t.createdAt)?void 0:o.toMillis())||0)-i})}catch(e){return console.error("Error fetching reviews (fallback):",e),[]}}static async getReviewsByDish(e){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("dishId","==",e),(0,o.orderBy)("createdAt","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(t){console.error("Error fetching reviews by dish:",t);try{return(await (0,o.getDocs)((0,o.collection)(i.db,this.collection))).docs.map(e=>({id:e.id,...e.data()})).filter(t=>t.dishId===e).sort((e,t)=>{var r,o;let i=(null==(r=e.createdAt)?void 0:r.toMillis())||0;return((null==(o=t.createdAt)?void 0:o.toMillis())||0)-i})}catch(e){return console.error("Error in fallback review fetch:",e),[]}}}static async getReviewsByOrder(e){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("orderId","==",e)))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching reviews by order:",e),[]}}static async createReview(e){try{let t=await (0,o.gS)((0,o.collection)(i.db,this.collection),{...e,createdAt:o.Dc.now()});if(e.cookerId){let t=await this.getReviewsByCook(e.cookerId),r=t.length>0?t.reduce((e,t)=>e+t.rating,0)/t.length:e.rating;await a.updateCookProfile(e.cookerId,{rating:Number(r.toFixed(1)),reviewCount:t.length})}if(e.dishId){let t=await this.getReviewsByDish(e.dishId),r=t.length>0?t.reduce((e,t)=>e+t.rating,0)/t.length:e.rating;await c.updateDish(e.dishId,{rating:Number(r.toFixed(1)),reviewCount:t.length})}return t.id}catch(e){return console.error("Error creating review:",e),null}}}d.collection="reviews";class l{static async getAllDrivers(){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.orderBy)("rating","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching drivers:",e),[]}}static async getDriverById(e){try{let t=(0,o.doc)(i.db,this.collection,e),r=await (0,o.getDoc)(t);if(r.exists())return{id:r.id,...r.data()};return null}catch(e){return console.error("Error fetching driver:",e),null}}static async updateDriverProfile(e,t){try{console.log("Attempting to update driver profile:",e,t);let r=(0,o.doc)(i.db,this.collection,e);if(!(await (0,o.getDoc)(r)).exists())return console.error("Driver document does not exist:",e),!1;return await (0,o.mZ)(r,{...t,updatedAt:o.Dc.now()}),console.log("Driver profile updated successfully"),!0}catch(r){return console.error("Error updating driver profile:",r),console.error("Error details:",{code:r.code,message:r.message,driverId:e,updates:t}),!1}}static async createDriverProfile(e,t){try{console.log("Creating driver profile:",t,e);let r=o.Dc.now();if(t){let c=(0,o.doc)(i.db,this.collection,t);return await (0,o.BN)(c,{...e,createdAt:r,updatedAt:r}),console.log("Driver profile created successfully with ID:",t),t}{let t=await (0,o.gS)((0,o.collection)(i.db,this.collection),{...e,createdAt:r,updatedAt:r});return console.log("Driver profile created successfully with ID:",t.id),t.id}}catch(r){return console.error("Error creating driver profile:",r),console.error("Error details:",{code:r.code,message:r.message,driverId:t,dataKeys:Object.keys(e)}),null}}static async deleteDriver(e){try{return await (0,o.kd)((0,o.doc)(i.db,this.collection,e)),!0}catch(e){return console.error("Error deleting driver:",e),!1}}static async getOrdersByDriver(e){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("driverId","==",e),(0,o.orderBy)("createdAt","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching driver orders:",e),[]}}static async getActiveOrdersByDriver(e){try{return(await (0,o.getDocs)((0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("driverId","==",e),(0,o.where)("status","in",["delivering","picked_up"]),(0,o.orderBy)("createdAt","desc")))).docs.map(e=>({id:e.id,...e.data()}))}catch(e){return console.error("Error fetching active driver orders:",e),[]}}static async getDriverStats(e){try{let t=await this.getOrdersByDriver(e),r=new Date;r.setHours(0,0,0,0),o.Dc.fromDate(r);let i=t.filter(e=>{var t;return((null==(t=e.createdAt)?void 0:t.toDate())||new Date(0))>=r}).filter(e=>"delivered"===e.status),c=i.reduce((e,t)=>e+(t.deliveryFee||0),0),a=t.filter(e=>"delivered"===e.status),s=t.length,d=s>0?a.length/s*100:0;return{todayEarnings:c,todayDeliveries:i.length,totalDeliveries:a.length,completionRate:d}}catch(e){return console.error("Error calculating driver stats:",e),{todayEarnings:0,todayDeliveries:0,totalDeliveries:0,completionRate:0}}}static subscribeToDriverOrders(e,t){let r=(0,o.query)((0,o.collection)(i.db,this.collection),(0,o.where)("driverId","==",e));return(0,o.aQ)(r,e=>{let r=e.docs.map(e=>({id:e.id,...e.data()}));r.sort((e,t)=>{var r,o;let i=(null==(r=e.createdAt)?void 0:r.toMillis())||0;return((null==(o=t.createdAt)?void 0:o.toMillis())||0)-i}),t(r)},e=>{console.error("Error in driver orders subscription:",e),t([])})}}l.collection="drivers";class n{static async deleteCook(e,t){try{let r=await c.getDishesByCook(e),a=r.map(e=>c.deleteDish(e.id));return await Promise.all(a),await (0,o.kd)((0,o.doc)(i.db,"cooks",e)),console.log("Admin ".concat(t," deleted cook ").concat(e," and ").concat(r.length," associated dishes")),!0}catch(e){return console.error("Error deleting cook (admin):",e),!1}}static async deleteDish(e,t){try{return await c.deleteDish(e),console.log("Admin ".concat(t," deleted dish ").concat(e)),!0}catch(e){return console.error("Error deleting dish (admin):",e),!1}}static async deleteDriver(e,t){try{return await l.deleteDriver(e),console.log("Admin ".concat(t," deleted driver ").concat(e)),!0}catch(e){return console.error("Error deleting driver (admin):",e),!1}}static async getAllUsers(){try{let[e,t,r]=await Promise.all([a.getAllCooks(),l.getAllDrivers(),c.getAllDishes()]);return{cooks:e,drivers:t,dishes:r}}catch(e){return console.error("Error fetching all users:",e),{cooks:[],drivers:[],dishes:[]}}}static async getUsersStatistics(){try{let[e,t]=await Promise.all([a.getAllCooks(),l.getAllDrivers()]),r=Math.max(50,(e.length+t.length)*3),o=Math.floor(.7*r);return{totalClients:r,totalCooks:e.length,totalDrivers:t.length,activeUsers:o}}catch(e){return console.error("Error getting user statistics:",e),{totalClients:0,totalCooks:0,totalDrivers:0,activeUsers:0}}}static async getOrdersStatistics(){try{let e=await s.getAllOrders(),t=new Date;t.setHours(0,0,0,0);let r=e.filter(e=>e.createdAt.toDate()>=t),o=e.filter(e=>["pending","accepted","preparing","ready","delivering"].includes(e.status)).length,i=r.filter(e=>"delivered"===e.status),c=i.reduce((e,t)=>e+t.total,0);return{totalOrders:e.length,activeOrders:o,todayRevenue:c,completedToday:i.length}}catch(e){return console.error("Error getting order statistics:",e),{totalOrders:0,activeOrders:0,todayRevenue:0,completedToday:0}}}static async isAdmin(e){try{let t=await (0,o.getDoc)((0,o.doc)(i.db,"users",e));if(t.exists()){let e=t.data();return"admin"===e.role||"Admin"===e.role}return!1}catch(e){return console.error("Error checking admin status:",e),!1}}}class u{static async getSettings(){try{let e=(0,o.doc)(i.db,this.collection,this.settingsDocId),t=await (0,o.getDoc)(e);if(t.exists())return{id:t.id,...t.data()};let r={deliveryFee:{baseRate:0,freeDeliveryThreshold:25e3,isEnabled:!1},serviceFee:{percentage:.12,isEnabled:!0},updatedAt:o.Dc.now(),updatedBy:"system"};try{await (0,o.BN)(e,r),console.log("Created default app settings")}catch(e){console.warn("Could not create default settings, using fallback:",e)}return{id:this.settingsDocId,...r}}catch(e){return console.error("Error fetching app settings:",e),{id:this.settingsDocId,deliveryFee:{baseRate:0,freeDeliveryThreshold:25e3,isEnabled:!1},serviceFee:{percentage:.12,isEnabled:!0},updatedAt:o.Dc.now(),updatedBy:"system"}}}static async updateSettings(e,t){try{let r=(0,o.doc)(i.db,this.collection,this.settingsDocId);return await (0,o.BN)(r,{...e,updatedAt:o.Dc.now(),updatedBy:t},{merge:!0}),!0}catch(e){return console.error("Error updating app settings:",e),!1}}}u.collection="appSettings",u.settingsDocId="main";class g{static async getCookStats(e){try{let t=await s.getOrdersByCook(e),r=t.filter(e=>"delivered"===e.status).reduce((e,t)=>e+t.total,0),o=(await c.getDishesByCook(e)).filter(e=>e.isAvailable).length,i=t.filter(e=>["pending","accepted","preparing","ready","delivering"].includes(e.status)).length,a=await d.getReviewsByCook(e),l=a.length>0?a.reduce((e,t)=>e+t.rating,0)/a.length:0;return{totalEarnings:r,activeDishes:o,pendingOrders:i,averageRating:Number(l.toFixed(1)),totalOrders:t.length,reviewCount:a.length}}catch(e){return console.error("Error calculating cook stats:",e),{totalEarnings:0,activeDishes:0,pendingOrders:0,averageRating:0,totalOrders:0,reviewCount:0}}}}}}]);