(()=>{var a={};a.id=8564,a.ids=[8564,9767],a.modules={261:a=>{"use strict";a.exports=require("next/dist/shared/lib/router/utils/app-paths")},3295:a=>{"use strict";a.exports=require("next/dist/server/app-render/after-task-async-storage.external.js")},10846:a=>{"use strict";a.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},19771:a=>{"use strict";a.exports=require("process")},21820:a=>{"use strict";a.exports=require("os")},27910:a=>{"use strict";a.exports=require("stream")},28354:a=>{"use strict";a.exports=require("util")},29021:a=>{"use strict";a.exports=require("fs")},29294:a=>{"use strict";a.exports=require("next/dist/server/app-render/work-async-storage.external.js")},33873:a=>{"use strict";a.exports=require("path")},34631:a=>{"use strict";a.exports=require("tls")},37366:a=>{"use strict";a.exports=require("dns")},44870:a=>{"use strict";a.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},55511:a=>{"use strict";a.exports=require("crypto")},63033:a=>{"use strict";a.exports=require("next/dist/server/app-render/work-unit-async-storage.external.js")},73496:a=>{"use strict";a.exports=require("http2")},74075:a=>{"use strict";a.exports=require("zlib")},78335:()=>{},79551:a=>{"use strict";a.exports=require("url")},79767:(a,b,c)=>{"use strict";let d;c.d(b,{db:()=>h});var e=c(89579),f=c(1767),g=c(34717);d=(0,e.Dk)().length?(0,e.Dk)()[0]:(0,e.Wp)({apiKey:"AIzaSyBptLm3y63BDBH9Xgt_UY40ZjsgUvMOKGI",authDomain:"hometaste-tlpog.firebaseapp.com",projectId:"hometaste-tlpog",storageBucket:"hometaste-tlpog.firebasestorage.app",messagingSenderId:"72297856520",appId:"1:72297856520:web:c7d851e4c00c67ec419bbd"}),(0,f.xI)(d);let h=(0,g.aU)(d)},81356:(a,b,c)=>{"use strict";c.r(b),c.d(b,{handler:()=>K,patchFetch:()=>J,routeModule:()=>F,serverHooks:()=>I,workAsyncStorage:()=>G,workUnitAsyncStorage:()=>H});var d={};c.r(d),c.d(d,{POST:()=>E});var e=c(96559),f=c(48088),g=c(37719),h=c(26191),i=c(81289),j=c(261),k=c(92603),l=c(39893),m=c(14823),n=c(47220),o=c(66946),p=c(47912),q=c(99786),r=c(46143),s=c(86439),t=c(43365),u=c(32190),v=c(34717),w=c(79767);class x{static{this.collection="dishes"}static async getAllDishes(){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v.My)("createdAt","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching dishes with orderBy, trying fallback:",a),this.getAllDishesFallback()}}static async getAllDishesFallback(){try{return(await (0,v.GG)((0,v.rJ)(w.db,this.collection))).docs.map(a=>({id:a.id,...a.data()})).sort((a,b)=>{let c=a.createdAt?.toMillis()||0;return(b.createdAt?.toMillis()||0)-c})}catch(a){return console.error("Error fetching dishes (fallback):",a),[]}}static async getDishesByCategory(a){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("category","==",a),(0,v._M)("isAvailable","==",!0),(0,v.My)("rating","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(b){return console.error("Error fetching dishes by category with index, trying fallback:",b),this.getDishesByCategoryFallback(a)}}static async getDishesByCategoryFallback(a){try{return(await (0,v.GG)((0,v.rJ)(w.db,this.collection))).docs.map(a=>({id:a.id,...a.data()})).filter(b=>b.category===a&&b.isAvailable).sort((a,b)=>(b.rating||0)-(a.rating||0))}catch(a){return console.error("Error fetching dishes by category (fallback):",a),[]}}static async getDishesByCook(a){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("cookerId","==",a),(0,v.My)("createdAt","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(b){return console.warn("Database index is building, using temporary fallback method..."),this.getDishesByCookFallback(a)}}static async getDishesByCookFallback(a){try{try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("cookerId","==",a)))).docs.map(a=>({id:a.id,...a.data()})).sort((a,b)=>{let c=a.createdAt?.toMillis()||0;return(b.createdAt?.toMillis()||0)-c})}catch(b){return console.warn("Simple query failed, using full collection scan..."),(await (0,v.GG)((0,v.rJ)(w.db,this.collection))).docs.map(a=>({id:a.id,...a.data()})).filter(b=>b.cookerId===a).sort((a,b)=>{let c=a.createdAt?.toMillis()||0;return(b.createdAt?.toMillis()||0)-c})}}catch(a){return console.error("Error fetching dishes by cook (fallback):",a),[]}}static async getDishById(a){try{let b=(0,v.doc)(w.db,this.collection,a),c=await (0,v.getDoc)(b);if(c.exists())return{id:c.id,...c.data()};return null}catch(a){return console.error("Error fetching dish:",a),null}}static async createDish(a){try{let b=v.Dc.now();return(await (0,v.gS)((0,v.rJ)(w.db,this.collection),{...a,createdAt:b,updatedAt:b})).id}catch(a){return console.error("Error creating dish:",a),null}}static async updateDish(a,b){try{let c=(0,v.doc)(w.db,this.collection,a);return await (0,v.mZ)(c,{...b,updatedAt:v.Dc.now()}),!0}catch(a){return console.error("Error updating dish:",a),!1}}static async deleteDish(a){try{return await (0,v.kd)((0,v.doc)(w.db,this.collection,a)),!0}catch(a){return console.error("Error deleting dish:",a),!1}}static async searchDishes(a){try{return(await (0,v.GG)((0,v.rJ)(w.db,this.collection))).docs.map(a=>({id:a.id,...a.data()})).filter(b=>b.name.toLowerCase().includes(a.toLowerCase())||b.description.toLowerCase().includes(a.toLowerCase())||b.tags.some(b=>b.toLowerCase().includes(a.toLowerCase()))||b.cookerName.toLowerCase().includes(a.toLowerCase()))}catch(a){return console.error("Error searching dishes:",a),[]}}static async getUserFavorites(a){try{let b=await (0,v.getDoc)((0,v.doc)(w.db,"favorites",a));if(b.exists())return b.data().dishIds||[];return[]}catch(a){return console.error("Error fetching user favorites:",a),[]}}static async addToFavorites(a,b){try{let c=(0,v.doc)(w.db,"favorites",a),d=await (0,v.getDoc)(c);if(d.exists()){let a=d.data().dishIds||[];a.includes(b)||await (0,v.mZ)(c,{dishIds:[...a,b],updatedAt:v.Dc.now()})}else await (0,v.BN)(c,{dishIds:[b],createdAt:v.Dc.now(),updatedAt:v.Dc.now()});return!0}catch(a){return console.error("Error adding to favorites:",a),!1}}static async removeFromFavorites(a,b){try{let c=(0,v.doc)(w.db,"favorites",a),d=await (0,v.getDoc)(c);if(d.exists()){let a=(d.data().dishIds||[]).filter(a=>a!==b);await (0,v.mZ)(c,{dishIds:a,updatedAt:v.Dc.now()})}return!0}catch(a){return console.error("Error removing from favorites:",a),!1}}}class y{static{this.collection="cooks"}static async getAllCooks(){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v.My)("rating","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching cooks:",a),[]}}static async getCookById(a){try{let b=(0,v.doc)(w.db,this.collection,a),c=await (0,v.getDoc)(b);if(c.exists())return{id:c.id,...c.data()};return null}catch(a){return console.error("Error fetching cook:",a),null}}static async updateCookProfile(a,b){try{let c=(0,v.doc)(w.db,this.collection,a);return await (0,v.mZ)(c,{...b,updatedAt:v.Dc.now()}),!0}catch(a){return console.error("Error updating cook profile:",a),!1}}static async createCookProfile(a){try{let b=v.Dc.now();return(await (0,v.gS)((0,v.rJ)(w.db,this.collection),{...a,createdAt:b,updatedAt:b})).id}catch(a){return console.error("Error creating cook profile:",a),null}}static async createCookProfileWithId(a,b){try{let c=v.Dc.now(),d=(0,v.doc)(w.db,this.collection,a);return await (0,v.BN)(d,{...b,createdAt:c,updatedAt:c}),!0}catch(a){return console.error("Error creating cook profile with ID:",a),!1}}}class z{static{this.collection="orders"}static async getAllOrders(){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v.My)("createdAt","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching all orders:",a),[]}}static async getOrdersByCustomer(a){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("customerId","==",a),(0,v.My)("createdAt","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching customer orders:",a),[]}}static async getOrdersByCook(a){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("cookerId","==",a),(0,v.My)("createdAt","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching cook orders:",a),[]}}static async getOrderById(a){try{let b=(0,v.doc)(w.db,this.collection,a),c=await (0,v.getDoc)(b);if(c.exists())return{id:c.id,...c.data()};return null}catch(a){return console.error("Error fetching order by ID:",a),null}}static async createOrder(a){try{let b=v.Dc.now(),{generateDeliveryCode:d}=await Promise.all([c.e(4017),c.e(6819)]).then(c.bind(c,66819)),e=await (0,v.gS)((0,v.rJ)(w.db,this.collection),{...a,deliveryCode:a.deliveryCode||d(),isDelivered:!1,createdAt:b,updatedAt:b});try{let d=await y.getCookById(a.cookerId);if(d&&d.email){let{EmailService:f}=await c.e(368).then(c.bind(c,10368)),g={id:e.id,...a,createdAt:b,updatedAt:b};await f.sendOrderNotificationToCook(g,d),console.log(`Email notification sent to cook ${d.email} for order ${e.id}`)}}catch(a){console.error("Error sending email notification to cook:",a)}try{let{ChatService:b}=await c.e(614).then(c.bind(c,614));await b.getOrCreateOrderChatRoom(e.id,a.cookerId,a.customerId,a.driverId)}catch(a){console.warn("Could not create chat room for order:",a)}return e.id}catch(a){return console.error("Error creating order:",a),null}}static async updateOrderStatus(a,b,d){try{let e=(0,v.doc)(w.db,this.collection,a),f={status:b,updatedAt:v.Dc.now()};if("delivered"===b?(f.actualDeliveryTime=v.Dc.now(),f.isDelivered=!0):"ready"===b?(f.availableForPickup=!0,f.readyTime=v.Dc.now()):"delivering"===b&&d?.userId&&(f.driverId=d.userId,f.pickupTime=v.Dc.now()),await (0,v.mZ)(e,f),d&&["accepted","preparing","ready","delivering","delivered"].includes(b))try{let{ChatService:f}=await c.e(614).then(c.bind(c,614)),g=await (0,v.getDoc)(e);if(g.exists()){let c=g.data(),e=await f.getOrCreateOrderChatRoom(a,c.cookerId,c.customerId,c.driverId);e&&await f.sendOrderUpdateMessage(e,a,b,d.role)}}catch(a){console.warn("Could not send chat notification for status update:",a)}return!0}catch(a){return console.error("Error updating order status:",a),!1}}static async updateOrder(a,b){try{let c=(0,v.doc)(w.db,this.collection,a);return await (0,v.mZ)(c,{...b,updatedAt:v.Dc.now()}),!0}catch(a){return console.error("Error updating order:",a),!1}}static async verifyDeliveryCode(a,b){try{let c=(0,v.doc)(w.db,this.collection,a),d=await (0,v.getDoc)(c);if(!d.exists())return{success:!1,message:"Pedido no encontrado"};let e=d.data();if(e.isDelivered)return{success:!1,message:"Este pedido ya fue entregado"};if("delivering"!==e.status)return{success:!1,message:"Este pedido no est\xe1 en estado de entrega"};if(e.deliveryCode!==b)return{success:!1,message:"C\xf3digo de entrega incorrecto"};return await (0,v.mZ)(c,{status:"delivered",isDelivered:!0,actualDeliveryTime:v.Dc.now(),updatedAt:v.Dc.now()}),{success:!0,message:"Pedido entregado exitosamente"}}catch(a){return console.error("Error verifying delivery code:",a),{success:!1,message:"Error al verificar el c\xf3digo"}}}static async getOrderByDeliveryCode(a){try{let b=await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("deliveryCode","==",a),(0,v._M)("status","==","delivering"),(0,v._M)("isDelivered","==",!1)));if(b.empty)return null;let c=b.docs[0];return{id:c.id,...c.data()}}catch(a){return console.error("Error finding order by delivery code:",a),null}}static async getAvailableOrdersForDelivery(){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("status","in",["accepted","preparing","ready"]),(0,v.My)("createdAt","asc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching available orders:",a),[]}}static async assignOrderToDriver(a,b){try{let c=(0,v.doc)(w.db,this.collection,a);return await (0,v.mZ)(c,{driverId:b,status:"delivering",pickupTime:v.Dc.now(),updatedAt:v.Dc.now()}),!0}catch(a){return console.error("Error assigning order to driver:",a),!1}}static async getReadyOrdersForPickup(){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("status","==","ready")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching ready orders:",a),[]}}static subscribeToAvailableOrders(a){let b=(0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("status","in",["pending","accepted","preparing","ready"]));return(0,v.aQ)(b,b=>{let c=b.docs.map(a=>({id:a.id,...a.data()}));c.sort((a,b)=>(a.createdAt?.toMillis()||0)-(b.createdAt?.toMillis()||0)),a(c)},b=>{console.error("Error in available orders subscription:",b),a([])})}static subscribeToOrderUpdates(a,b){let c=(0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("cookerId","==",a),(0,v.My)("createdAt","desc"));return(0,v.aQ)(c,a=>{b(a.docs.map(a=>({id:a.id,...a.data()})))})}static subscribeToDriverAvailableOrders(a){let b=(0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("status","in",["pending","accepted","preparing","ready"]));return(0,v.aQ)(b,b=>{let c=b.docs.map(a=>({id:a.id,...a.data()}));c.sort((a,b)=>(a.createdAt?.toMillis()||0)-(b.createdAt?.toMillis()||0)),a(c)},b=>{console.error("Error in driver available orders subscription:",b),a([])})}static subscribeToCustomerOrders(a,b){let c=(0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("customerId","==",a));return(0,v.aQ)(c,a=>{let c=a.docs.map(a=>({id:a.id,...a.data()}));c.sort((a,b)=>{let c=a.createdAt?.toDate()||new Date(0);return(b.createdAt?.toDate()||new Date(0)).getTime()-c.getTime()}),b(c)},a=>{console.error("Error in customer orders subscription:",a),b([])})}static subscribeToOrdersByCook(a,b){let c=(0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("cookerId","==",a));return(0,v.aQ)(c,a=>{let c=a.docs.map(a=>({id:a.id,...a.data()}));c.sort((a,b)=>{let c=a.createdAt?.toDate()||new Date(0);return(b.createdAt?.toDate()||new Date(0)).getTime()-c.getTime()}),b(c)},a=>{console.error("Error in cook orders subscription:",a),b([])})}static subscribeToOrder(a,b){return(0,v.aQ)((0,v.doc)(w.db,this.collection,a),a=>{a.exists()?b({id:a.id,...a.data()}):b(null)},a=>{console.error("Error in order subscription:",a),b(null)})}static async addOrderReview(a,b){try{return await (0,v.mZ)((0,v.doc)(w.db,this.collection,a),{review:b,reviewed:!0,updatedAt:v.Dc.now()}),!0}catch(a){return console.error("Error adding order review:",a),!1}}static async deleteOrder(a){try{return await (0,v.kd)((0,v.doc)(w.db,this.collection,a)),!0}catch(a){return console.error("Error deleting order:",a),!1}}static async startDeliveryTracking(a,b){try{let c=v.Dc.now();return await (0,v.mZ)((0,v.doc)(w.db,this.collection,a),{status:"en_viaje",tracking:{driverLocation:{...b,timestamp:c},trackingStarted:c,lastLocationUpdate:c},updatedAt:c}),!0}catch(a){return console.error("Error starting delivery tracking:",a),!1}}static async updateDriverLocation(a,b,c){try{let d=v.Dc.now(),e={"tracking.driverLocation":{...b,timestamp:d},"tracking.lastLocationUpdate":d,updatedAt:d};return c&&(e["tracking.route"]={...c,estimatedArrival:v.Dc.fromDate(c.estimatedArrival)}),await (0,v.mZ)((0,v.doc)(w.db,this.collection,a),e),!0}catch(a){return console.error("Error updating driver location:",a),!1}}static async endDeliveryTracking(a){try{let b=v.Dc.now();return await (0,v.mZ)((0,v.doc)(w.db,this.collection,a),{status:"delivered","tracking.trackingEnded":b,actualDeliveryTime:b,updatedAt:b}),!0}catch(a){return console.error("Error ending delivery tracking:",a),!1}}static async getOrdersWithDetails(){try{let a=await this.getAllOrders(),b=[...new Set(a.map(a=>a.cookerId).filter(Boolean))],c=[...new Set(a.map(a=>a.driverId).filter(Boolean))],[d,e]=await Promise.all([Promise.all(b.map(async a=>{let b=await y.getCookById(a);return{id:a,data:b}})),Promise.all(c.map(async a=>{let b=await B.getDriverById(a);return{id:a,data:b}}))]),f=new Map(d.map(a=>[a.id,a.data])),g=new Map(e.map(a=>[a.id,a.data]));return a.map(a=>({...a,cookInfo:a.cookerId?f.get(a.cookerId):void 0,driverInfo:a.driverId?g.get(a.driverId):void 0}))}catch(a){return console.error("Error getting orders with details:",a),[]}}}class A{static{this.collection="reviews"}static async getReviewsByCook(a){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("cookerId","==",a),(0,v.My)("createdAt","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(b){return console.error("Error fetching reviews with index, trying fallback:",b),this.getReviewsByCookFallback(a)}}static async getReviewsByCookFallback(a){try{return(await (0,v.GG)((0,v.rJ)(w.db,this.collection))).docs.map(a=>({id:a.id,...a.data()})).filter(b=>b.cookerId===a).sort((a,b)=>{let c=a.createdAt?.toMillis()||0;return(b.createdAt?.toMillis()||0)-c})}catch(a){return console.error("Error fetching reviews (fallback):",a),[]}}static async getReviewsByDish(a){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("dishId","==",a),(0,v.My)("createdAt","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(b){console.error("Error fetching reviews by dish:",b);try{return(await (0,v.GG)((0,v.rJ)(w.db,this.collection))).docs.map(a=>({id:a.id,...a.data()})).filter(b=>b.dishId===a).sort((a,b)=>{let c=a.createdAt?.toMillis()||0;return(b.createdAt?.toMillis()||0)-c})}catch(a){return console.error("Error in fallback review fetch:",a),[]}}}static async getReviewsByOrder(a){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("orderId","==",a)))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching reviews by order:",a),[]}}static async createReview(a){try{let b=await (0,v.gS)((0,v.rJ)(w.db,this.collection),{...a,createdAt:v.Dc.now()});if(a.cookerId){let b=await this.getReviewsByCook(a.cookerId),c=b.length>0?b.reduce((a,b)=>a+b.rating,0)/b.length:a.rating;await y.updateCookProfile(a.cookerId,{rating:Number(c.toFixed(1)),reviewCount:b.length})}if(a.dishId){let b=await this.getReviewsByDish(a.dishId),c=b.length>0?b.reduce((a,b)=>a+b.rating,0)/b.length:a.rating;await x.updateDish(a.dishId,{rating:Number(c.toFixed(1)),reviewCount:b.length})}return b.id}catch(a){return console.error("Error creating review:",a),null}}}class B{static{this.collection="drivers"}static async getAllDrivers(){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v.My)("rating","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching drivers:",a),[]}}static async getDriverById(a){try{let b=(0,v.doc)(w.db,this.collection,a),c=await (0,v.getDoc)(b);if(c.exists())return{id:c.id,...c.data()};return null}catch(a){return console.error("Error fetching driver:",a),null}}static async updateDriverProfile(a,b){try{console.log("Attempting to update driver profile:",a,b);let c=(0,v.doc)(w.db,this.collection,a);if(!(await (0,v.getDoc)(c)).exists())return console.error("Driver document does not exist:",a),!1;return await (0,v.mZ)(c,{...b,updatedAt:v.Dc.now()}),console.log("Driver profile updated successfully"),!0}catch(c){return console.error("Error updating driver profile:",c),console.error("Error details:",{code:c.code,message:c.message,driverId:a,updates:b}),!1}}static async createDriverProfile(a,b){try{console.log("Creating driver profile:",b,a);let c=v.Dc.now();if(b){let d=(0,v.doc)(w.db,this.collection,b);return await (0,v.BN)(d,{...a,createdAt:c,updatedAt:c}),console.log("Driver profile created successfully with ID:",b),b}{let b=await (0,v.gS)((0,v.rJ)(w.db,this.collection),{...a,createdAt:c,updatedAt:c});return console.log("Driver profile created successfully with ID:",b.id),b.id}}catch(c){return console.error("Error creating driver profile:",c),console.error("Error details:",{code:c.code,message:c.message,driverId:b,dataKeys:Object.keys(a)}),null}}static async deleteDriver(a){try{return await (0,v.kd)((0,v.doc)(w.db,this.collection,a)),!0}catch(a){return console.error("Error deleting driver:",a),!1}}static async getOrdersByDriver(a){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("driverId","==",a),(0,v.My)("createdAt","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching driver orders:",a),[]}}static async getActiveOrdersByDriver(a){try{return(await (0,v.GG)((0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("driverId","==",a),(0,v._M)("status","in",["delivering","picked_up"]),(0,v.My)("createdAt","desc")))).docs.map(a=>({id:a.id,...a.data()}))}catch(a){return console.error("Error fetching active driver orders:",a),[]}}static async getDriverStats(a){try{let b=await this.getOrdersByDriver(a),c=new Date;c.setHours(0,0,0,0),v.Dc.fromDate(c);let d=b.filter(a=>(a.createdAt?.toDate()||new Date(0))>=c).filter(a=>"delivered"===a.status),e=d.reduce((a,b)=>a+(b.deliveryFee||0),0),f=b.filter(a=>"delivered"===a.status),g=b.length,h=g>0?f.length/g*100:0;return{todayEarnings:e,todayDeliveries:d.length,totalDeliveries:f.length,completionRate:h}}catch(a){return console.error("Error calculating driver stats:",a),{todayEarnings:0,todayDeliveries:0,totalDeliveries:0,completionRate:0}}}static subscribeToDriverOrders(a,b){let c=(0,v.P)((0,v.rJ)(w.db,this.collection),(0,v._M)("driverId","==",a));return(0,v.aQ)(c,a=>{let c=a.docs.map(a=>({id:a.id,...a.data()}));c.sort((a,b)=>{let c=a.createdAt?.toMillis()||0;return(b.createdAt?.toMillis()||0)-c}),b(c)},a=>{console.error("Error in driver orders subscription:",a),b([])})}}class C{static{this.collection="appSettings"}static{this.settingsDocId="main"}static async getSettings(){try{let a=(0,v.doc)(w.db,this.collection,this.settingsDocId),b=await (0,v.getDoc)(a);if(b.exists())return{id:b.id,...b.data()};let c={deliveryFee:{baseRate:0,freeDeliveryThreshold:25e3,isEnabled:!1},serviceFee:{percentage:.12,isEnabled:!0},updatedAt:v.Dc.now(),updatedBy:"system"};try{await (0,v.BN)(a,c),console.log("Created default app settings")}catch(a){console.warn("Could not create default settings, using fallback:",a)}return{id:this.settingsDocId,...c}}catch(a){return console.error("Error fetching app settings:",a),{id:this.settingsDocId,deliveryFee:{baseRate:0,freeDeliveryThreshold:25e3,isEnabled:!1},serviceFee:{percentage:.12,isEnabled:!0},updatedAt:v.Dc.now(),updatedBy:"system"}}}static async updateSettings(a,b){try{let c=(0,v.doc)(w.db,this.collection,this.settingsDocId);return await (0,v.BN)(c,{...a,updatedAt:v.Dc.now(),updatedBy:b},{merge:!0}),!0}catch(a){return console.error("Error updating app settings:",a),!1}}}let D=process.env.MERCADO_PAGO_ACCESS_TOKEN;async function E(a){try{let b=await a.json();if(console.log("Mercado Pago webhook received:",b),"payment"===b.type){let a,c=b.data.id,d=await fetch(`https://api.mercadopago.com/v1/payments/${c}`,{method:"GET",headers:{Authorization:`Bearer ${D}`,"Content-Type":"application/json"}});if(!d.ok)throw Error(`MercadoPago API error: ${d.status}`);let e=await d.json();console.log("Payment data:",e);let f=e.external_reference,g=e.status;switch(g){case"approved":a="accepted";break;case"pending":case"in_process":default:a="pending";break;case"rejected":case"cancelled":a="cancelled"}if(f)try{await z.updateOrderStatus(f,a),console.log(`Order ${f} updated to status: ${a}`)}catch(a){console.error("Error updating order status:",a)}console.log(`Payment ${c} processed: ${g}`)}return u.NextResponse.json({received:!0})}catch(a){return console.error("Webhook error:",a),u.NextResponse.json({error:"Webhook processing failed"},{status:500})}}let F=new e.AppRouteRouteModule({definition:{kind:f.RouteKind.APP_ROUTE,page:"/api/mercadopago/webhook/route",pathname:"/api/mercadopago/webhook",filename:"route",bundlePath:"app/api/mercadopago/webhook/route"},distDir:".next",projectDir:"",resolvedPagePath:"D:\\Moai\\moai-app\\app\\api\\mercadopago\\webhook\\route.ts",nextConfigOutput:"",userland:d}),{workAsyncStorage:G,workUnitAsyncStorage:H,serverHooks:I}=F;function J(){return(0,g.patchFetch)({workAsyncStorage:G,workUnitAsyncStorage:H})}async function K(a,b,c){var d;let e="/api/mercadopago/webhook/route";"/index"===e&&(e="/");let g=await F.prepare(a,b,{srcPage:e,multiZoneDraftMode:"false"});if(!g)return b.statusCode=400,b.end("Bad Request"),null==c.waitUntil||c.waitUntil.call(c,Promise.resolve()),null;let{buildId:u,params:v,nextConfig:w,isDraftMode:x,prerenderManifest:y,routerServerContext:z,isOnDemandRevalidate:A,revalidateOnlyGenerated:B,resolvedPathname:C}=g,D=(0,j.normalizeAppPath)(e),E=!!(y.dynamicRoutes[D]||y.routes[C]);if(E&&!x){let a=!!y.routes[C],b=y.dynamicRoutes[D];if(b&&!1===b.fallback&&!a)throw new s.NoFallbackError}let G=null;!E||F.isDev||x||(G="/index"===(G=C)?"/":G);let H=!0===F.isDev||!E,I=E&&!H,J=a.method||"GET",K=(0,i.getTracer)(),L=K.getActiveScopeSpan(),M={params:v,prerenderManifest:y,renderOpts:{experimental:{dynamicIO:!!w.experimental.dynamicIO,authInterrupts:!!w.experimental.authInterrupts},supportsDynamicResponse:H,incrementalCache:(0,h.getRequestMeta)(a,"incrementalCache"),cacheLifeProfiles:null==(d=w.experimental)?void 0:d.cacheLife,isRevalidate:I,waitUntil:c.waitUntil,onClose:a=>{b.on("close",a)},onAfterTaskError:void 0,onInstrumentationRequestError:(b,c,d)=>F.onRequestError(a,b,d,z)},sharedContext:{buildId:u}},N=new k.NodeNextRequest(a),O=new k.NodeNextResponse(b),P=l.NextRequestAdapter.fromNodeNextRequest(N,(0,l.signalFromNodeResponse)(b));try{let d=async c=>F.handle(P,M).finally(()=>{if(!c)return;c.setAttributes({"http.status_code":b.statusCode,"next.rsc":!1});let d=K.getRootSpanAttributes();if(!d)return;if(d.get("next.span_type")!==m.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${d.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let e=d.get("next.route");if(e){let a=`${J} ${e}`;c.setAttributes({"next.route":e,"http.route":e,"next.span_name":a}),c.updateName(a)}else c.updateName(`${J} ${a.url}`)}),g=async g=>{var i,j;let k=async({previousCacheEntry:f})=>{try{if(!(0,h.getRequestMeta)(a,"minimalMode")&&A&&B&&!f)return b.statusCode=404,b.setHeader("x-nextjs-cache","REVALIDATED"),b.end("This page could not be found"),null;let e=await d(g);a.fetchMetrics=M.renderOpts.fetchMetrics;let i=M.renderOpts.pendingWaitUntil;i&&c.waitUntil&&(c.waitUntil(i),i=void 0);let j=M.renderOpts.collectedTags;if(!E)return await (0,o.I)(N,O,e,M.renderOpts.pendingWaitUntil),null;{let a=await e.blob(),b=(0,p.toNodeOutgoingHttpHeaders)(e.headers);j&&(b[r.NEXT_CACHE_TAGS_HEADER]=j),!b["content-type"]&&a.type&&(b["content-type"]=a.type);let c=void 0!==M.renderOpts.collectedRevalidate&&!(M.renderOpts.collectedRevalidate>=r.INFINITE_CACHE)&&M.renderOpts.collectedRevalidate,d=void 0===M.renderOpts.collectedExpire||M.renderOpts.collectedExpire>=r.INFINITE_CACHE?void 0:M.renderOpts.collectedExpire;return{value:{kind:t.CachedRouteKind.APP_ROUTE,status:e.status,body:Buffer.from(await a.arrayBuffer()),headers:b},cacheControl:{revalidate:c,expire:d}}}}catch(b){throw(null==f?void 0:f.isStale)&&await F.onRequestError(a,b,{routerKind:"App Router",routePath:e,routeType:"route",revalidateReason:(0,n.c)({isRevalidate:I,isOnDemandRevalidate:A})},z),b}},l=await F.handleResponse({req:a,nextConfig:w,cacheKey:G,routeKind:f.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:y,isRoutePPREnabled:!1,isOnDemandRevalidate:A,revalidateOnlyGenerated:B,responseGenerator:k,waitUntil:c.waitUntil});if(!E)return null;if((null==l||null==(i=l.value)?void 0:i.kind)!==t.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==l||null==(j=l.value)?void 0:j.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});(0,h.getRequestMeta)(a,"minimalMode")||b.setHeader("x-nextjs-cache",A?"REVALIDATED":l.isMiss?"MISS":l.isStale?"STALE":"HIT"),x&&b.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let m=(0,p.fromNodeOutgoingHttpHeaders)(l.value.headers);return(0,h.getRequestMeta)(a,"minimalMode")&&E||m.delete(r.NEXT_CACHE_TAGS_HEADER),!l.cacheControl||b.getHeader("Cache-Control")||m.get("Cache-Control")||m.set("Cache-Control",(0,q.getCacheControlHeader)(l.cacheControl)),await (0,o.I)(N,O,new Response(l.value.body,{headers:m,status:l.value.status||200})),null};L?await g(L):await K.withPropagatedContext(a.headers,()=>K.trace(m.BaseServerSpan.handleRequest,{spanName:`${J} ${a.url}`,kind:i.SpanKind.SERVER,attributes:{"http.method":J,"http.target":a.url}},g))}catch(b){if(L||b instanceof s.NoFallbackError||await F.onRequestError(a,b,{routerKind:"App Router",routePath:D,routeType:"route",revalidateReason:(0,n.c)({isRevalidate:I,isOnDemandRevalidate:A})}),E)throw b;return await (0,o.I)(N,O,new Response(null,{status:500})),null}}},81630:a=>{"use strict";a.exports=require("http")},86439:a=>{"use strict";a.exports=require("next/dist/shared/lib/no-fallback-error.external")},91645:a=>{"use strict";a.exports=require("net")},94735:a=>{"use strict";a.exports=require("events")},96487:()=>{}};var b=require("../../../../webpack-runtime.js");b.C(a);var c=b.X(0,[4985,6055,4717,6689],()=>b(b.s=81356));module.exports=c})();